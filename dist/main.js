/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LogseqToObsidian
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var DEFAULT_SETTINGS = {
  convertTodoToCheckbox: false
};
var LogseqToObsidian = class extends import_obsidian.Plugin {
  async onload() {
    console.log("LogseqToObsidian \u63D2\u4EF6\u5DF2\u52A0\u8F7D - \u7248\u672C 0.2.2");
    await this.loadSettings();
    this.addSettingTab(new LogseqToObsidianSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (file && file.extension === "md") {
          this.convertSyntax(file);
        } else {
          console.log(`[LogseqToObsidian] \u8DF3\u8FC7\u975EMD\u6587\u4EF6: ${file ? file.path : "null"}`);
        }
      })
    );
    this.registerMarkdownPostProcessor((element, context) => {
      this.renderBlockReferences(element, context);
    });
    this.registerEditorExtension(this.createBlockRefExtension());
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("LogseqToObsidian: \u5DF2\u542F\u7528");
    console.log("LogseqToObsidian \u63D2\u4EF6\u521D\u59CB\u5316\u5B8C\u6210");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  createBlockRefExtension() {
    const plugin = this;
    class BlockRefWidget extends import_view.WidgetType {
      constructor(blockId) {
        super();
        this.blockId = blockId;
      }
      toDOM() {
        const span = document.createElement("span");
        span.className = "logseq-block-ref";
        span.style.cssText = "display: inline;";
        const refIcon = document.createElement("span");
        refIcon.textContent = "\u2197 ";
        refIcon.style.cssText = "opacity: 0.5; font-size: 0.9em;";
        span.appendChild(refIcon);
        const contentSpan = document.createElement("span");
        contentSpan.textContent = "\u52A0\u8F7D\u4E2D...";
        span.appendChild(contentSpan);
        plugin.findBlockContent(this.blockId).then(async (result) => {
          if (result) {
            contentSpan.empty();
            await import_obsidian.MarkdownRenderer.renderMarkdown(
              result.content,
              contentSpan,
              "",
              plugin
            );
            span.title = `\u5757\u5F15\u7528: ${this.blockId}`;
            console.log(`[LogseqToObsidian] \u5B9E\u65F6\u9884\u89C8\u6E32\u67D3\u5757\u5185\u5BB9: ${result.content} (\u6587\u4EF6: ${result.file.basename})`);
          } else {
            contentSpan.textContent = `((${this.blockId}))`;
            contentSpan.style.color = "var(--text-error)";
            span.title = "\u672A\u627E\u5230\u5757\u5185\u5BB9";
            console.log(`[LogseqToObsidian] \u5B9E\u65F6\u9884\u89C8\u672A\u627E\u5230\u5757: ${this.blockId}`);
          }
        }).catch((err) => {
          console.error(`[LogseqToObsidian] \u5B9E\u65F6\u9884\u89C8\u52A0\u8F7D\u5931\u8D25: ${err}`);
          contentSpan.textContent = `((${this.blockId}))`;
          contentSpan.style.color = "var(--text-error)";
        });
        return span;
      }
      ignoreEvent() {
        return false;
      }
    }
    return import_view.ViewPlugin.fromClass(class {
      constructor(view) {
        this.decorations = this.buildDecorations(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged) {
          this.decorations = this.buildDecorations(update.view);
        }
      }
      buildDecorations(view) {
        const widgets = [];
        const blockRefPattern = /\(\(([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\)\)/g;
        for (let { from, to } of view.visibleRanges) {
          const text = view.state.doc.sliceString(from, to);
          let match;
          while ((match = blockRefPattern.exec(text)) !== null) {
            const blockId = match[1];
            const start = from + match.index;
            const end = start + match[0].length;
            console.log(`[LogseqToObsidian] \u5B9E\u65F6\u9884\u89C8\u627E\u5230\u5757\u5F15\u7528: ${blockId}`);
            widgets.push(
              import_view.Decoration.replace({
                widget: new BlockRefWidget(blockId),
                inclusive: false,
                block: false
              }).range(start, end)
            );
          }
        }
        return import_view.Decoration.set(widgets);
      }
    }, {
      decorations: (v) => v.decorations
    });
  }
  async findBlockContent(blockId) {
    const searchPaths = ["journals", "pages"];
    const searchFolder = async (folder) => {
      if (!folder || !folder.children)
        return null;
      for (const child of folder.children) {
        if (child.extension === "md") {
          const fileContent = await this.app.vault.read(child);
          const blockContent = this.extractBlockContent(fileContent, blockId);
          if (blockContent) {
            return { content: blockContent, file: child };
          }
        } else if (child.children) {
          const result = await searchFolder(child);
          if (result)
            return result;
        }
      }
      return null;
    };
    for (const path of searchPaths) {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (folder) {
        const result = await searchFolder(folder);
        if (result)
          return result;
      }
    }
    const allFiles = this.app.vault.getMarkdownFiles();
    for (const mdFile of allFiles) {
      if (searchPaths.some((path) => mdFile.path.startsWith(path)))
        continue;
      const fileContent = await this.app.vault.read(mdFile);
      const blockContent = this.extractBlockContent(fileContent, blockId);
      if (blockContent) {
        return { content: blockContent, file: mdFile };
      }
    }
    return null;
  }
  extractBlockContent(fileContent, blockId) {
    const lines = fileContent.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const idMatch = lines[i].match(/^\s*id::\s*([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\s*$/i);
      if (idMatch && idMatch[1] === blockId) {
        for (let j = i - 1; j >= 0; j--) {
          const line = lines[j].trim();
          if (line !== "") {
            return line;
          }
        }
      }
      const obsidianMatch = lines[i].match(/^(.+?)\s*\^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\s*$/i);
      if (obsidianMatch && obsidianMatch[2] === blockId) {
        return obsidianMatch[1].trim();
      }
    }
    return null;
  }
  async renderBlockReferences(element, context) {
    const blockRefPattern = /\(\(([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\)\)/g;
    const processNode = (node) => {
      var _a;
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        if (blockRefPattern.test(text)) {
          console.log(`[LogseqToObsidian] \u627E\u5230\u5757\u5F15\u7528: ${text}`);
          blockRefPattern.lastIndex = 0;
          let match;
          let lastIndex = 0;
          const fragments = [];
          while ((match = blockRefPattern.exec(text)) !== null) {
            const blockId = match[1];
            console.log(`[LogseqToObsidian] \u5904\u7406\u5757ID: ${blockId}`);
            if (match.index > lastIndex) {
              fragments.push(document.createTextNode(text.substring(lastIndex, match.index)));
            }
            const blockRefEl = document.createElement("span");
            blockRefEl.className = "logseq-block-ref";
            blockRefEl.style.cssText = "display: inline;";
            const refIcon = document.createElement("span");
            refIcon.textContent = "\u2197 ";
            refIcon.style.cssText = "opacity: 0.5; font-size: 0.9em;";
            blockRefEl.appendChild(refIcon);
            const contentSpan = document.createElement("span");
            contentSpan.textContent = "\u52A0\u8F7D\u4E2D...";
            blockRefEl.appendChild(contentSpan);
            this.findBlockContent(blockId).then(async (result) => {
              if (result) {
                contentSpan.empty();
                await import_obsidian.MarkdownRenderer.renderMarkdown(
                  result.content,
                  contentSpan,
                  context.sourcePath,
                  this
                );
                blockRefEl.title = `\u5757\u5F15\u7528: ${blockId}`;
                console.log(`[LogseqToObsidian] \u6210\u529F\u6E32\u67D3\u5757\u5185\u5BB9: ${result.content} (\u6587\u4EF6: ${result.file.basename})`);
              } else {
                contentSpan.textContent = `((${blockId}))`;
                contentSpan.style.color = "var(--text-error)";
                blockRefEl.title = "\u672A\u627E\u5230\u5757\u5185\u5BB9";
                console.log(`[LogseqToObsidian] \u672A\u627E\u5230\u5757\u5185\u5BB9: ${blockId}`);
              }
            }).catch((err) => {
              console.error(`[LogseqToObsidian] \u52A0\u8F7D\u5757\u5185\u5BB9\u5931\u8D25: ${err}`);
              contentSpan.textContent = `((${blockId}))`;
              contentSpan.style.color = "var(--text-error)";
            });
            fragments.push(blockRefEl);
            lastIndex = blockRefPattern.lastIndex;
          }
          if (lastIndex < text.length) {
            fragments.push(document.createTextNode(text.substring(lastIndex)));
          }
          if (fragments.length > 0) {
            const parent = node.parentNode;
            if (parent) {
              fragments.forEach((fragment) => {
                parent.insertBefore(fragment, node);
              });
              parent.removeChild(node);
            }
          }
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const el = node;
        if (el.tagName === "CODE" || el.tagName === "PRE" || ((_a = el.classList) == null ? void 0 : _a.contains("logseq-block-ref"))) {
          return;
        }
        const children = Array.from(node.childNodes);
        children.forEach((child) => processNode(child));
      }
    };
    processNode(element);
  }
  async convertSyntax(file) {
    var _a;
    const content = await this.app.vault.read(file);
    let newContent = content;
    const timeStrToSeconds = function(t) {
      const [h, m, s] = t.split(":").map(Number);
      return h * 3600 + m * 60 + s;
    };
    const formatDuration = function(seconds) {
      if (seconds < 60)
        return `${seconds}\u79D2`;
      if (seconds < 3600)
        return `${Math.floor(seconds / 60)}\u5206\u949F`;
      return `${Math.floor(seconds / 3600)}\u5C0F\u65F6`;
    };
    let linesForIdProcessing = newContent.split("\n");
    let updatedLines = [];
    let skipIndices = /* @__PURE__ */ new Set();
    const idLinePattern = /^(.*?)\s*id::\s*([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\s*$/;
    for (let i = 0; i < linesForIdProcessing.length; i++) {
      const match = idLinePattern.exec(linesForIdProcessing[i]);
      if (match) {
        const blockId = match[2];
        for (let j = i - 1; j >= 0; j--) {
          if (linesForIdProcessing[j].trim() !== "" && !linesForIdProcessing[j].includes("id::")) {
            const blockLine = linesForIdProcessing[j];
            const leadingSpaces = ((_a = blockLine.match(/^\s*/)) == null ? void 0 : _a[0]) || "";
            const contentAfterSpaces = blockLine.substring(leadingSpaces.length);
            linesForIdProcessing[j] = leadingSpaces + contentAfterSpaces.trim() + ` ^${blockId}`;
            let needsEmptyLineAfterBlock = false;
            let firstContentLineIndex = -1;
            for (let k = i + 1; k < linesForIdProcessing.length && !skipIndices.has(k); k++) {
              const lineAfterIdLine = linesForIdProcessing[k];
              if (lineAfterIdLine.trim() !== "") {
                needsEmptyLineAfterBlock = true;
                firstContentLineIndex = k;
                linesForIdProcessing[firstContentLineIndex] = lineAfterIdLine.trim();
                break;
              }
            }
            if (needsEmptyLineAfterBlock) {
              linesForIdProcessing.splice(j + 1, 0, "", "");
              for (let k = 0; k < linesForIdProcessing.length; k++) {
                if (k > j) {
                  if (skipIndices.has(k)) {
                    skipIndices.delete(k);
                    skipIndices.add(k + 2);
                  }
                }
              }
              i += 2;
            }
            skipIndices.add(i);
            break;
          }
        }
      }
    }
    for (let i = 0; i < linesForIdProcessing.length; i++) {
      if (!skipIndices.has(i)) {
        updatedLines.push(linesForIdProcessing[i]);
      }
    }
    newContent = updatedLines.join("\n");
    let linesForExistingBlocks = newContent.split("\n");
    for (let i = 0; i < linesForExistingBlocks.length; i++) {
      const line = linesForExistingBlocks[i];
      const blockMatch = line.match(/^(.+?)\s*\^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\s*$/);
      if (blockMatch) {
        if (i + 1 < linesForExistingBlocks.length) {
          const nextLine = linesForExistingBlocks[i + 1];
          if (nextLine.trim() !== "") {
            linesForExistingBlocks.splice(i + 1, 0, "", "");
            i += 2;
          }
        }
      }
    }
    newContent = linesForExistingBlocks.join("\n");
    newContent = newContent.replace(
      /([ \t]*)- DONE (.+?)\s*\n([ \t]*:LOGBOOK:\s*\n((?:[ \t]*CLOCK: \[.*?\]--\[.*?\] =>\s*\d{2}:\d{2}:\d{2}\s*\n)+)[ \t]*:END:)/gms,
      (match, indent, taskText, logbook, clockBlock) => {
        const times = clockBlock.match(/=> *(\d{2}:\d{2}:\d{2})/g) || [];
        const totalSeconds = times.reduce((sum, t) => sum + timeStrToSeconds(t.replace(/=> */g, "")), 0);
        const durationStr = formatDuration(totalSeconds);
        return `${indent}- DONE ${taskText.trim()} ${durationStr}`;
      }
    );
    if (this.settings.convertTodoToCheckbox) {
      newContent = newContent.replace(/([ \t]*)- TODO\b/gm, "$1- [ ]");
      newContent = newContent.replace(/([ \t]*)- DOING\b/gm, "$1- [ ]");
      newContent = newContent.replace(/([ \t]*)- DONE\b(.*)/gm, "$1- [x]$2");
    }
    if (newContent !== content) {
      await this.app.vault.modify(file, newContent);
    }
  }
};
var LogseqToObsidianSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Logseq to Obsidian \u8F6C\u6362\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u8F6C\u6362 TODO \u4E3A\u590D\u9009\u6846").setDesc("\u542F\u7528\u540E\uFF0C\u5C06 Logseq \u7684 TODO/DOING/DONE \u8F6C\u6362\u4E3A Obsidian \u7684 [ ] \u548C [x] \u590D\u9009\u6846\u3002\u7981\u7528\u540E\u4FDD\u6301 Logseq \u539F\u683C\u5F0F\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.convertTodoToCheckbox).onChange(async (value) => {
      this.plugin.settings.convertTodoToCheckbox = value;
      await this.plugin.saveSettings();
    }));
  }
};
